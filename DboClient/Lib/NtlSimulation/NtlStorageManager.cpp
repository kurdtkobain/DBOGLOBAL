//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CNtlStorageManager.cpp
//  @ Date : 2009-01-22
//  @ Author : 
//
//

#include "precomp_ntlsimulation.h"
#include "NtlStorageManager.h"

// Group
#include "NtlStorageGroupAccount.h"
#include "NtlStorageGroupSystem.h"
#include "NtlStorageGroupGameInfo.h"
#include "NtlStorageGroupScouter.h"
#include "NtlStorageGroupQuest.h"
#include "NtlStorageGroupCharacter.h"

// Serializer
#include "NtlStorageBinarySerializer.h"
#include "NtlStorageTextSerializer.h"

// Mapping
#include "NtlStorageMTContainer.h"

// Test
#include "PerformanceChecker.h"
#include "NtlCoreUtil.h"

#include "NtlDebug.h"

CNtlStorageManager::CNtlStorageManager()
{
	Create();
}

CNtlStorageManager::~CNtlStorageManager()
{
	Destroy();
}

bool CNtlStorageManager::Create()
{
	// Account Group
	CNtlStorageGroupAccount* pAccountGroup = NTL_NEW CNtlStorageGroupAccount();
	if( !pAccountGroup->Create() )
	{
		pAccountGroup->Destroy();
		NTL_DELETE( pAccountGroup );
		return false;
	}
	m_mapStorageGroup.insert( std::make_pair( eNTL_STORAGE_GROUP_ACCOUNT, pAccountGroup ) );

	// System Group
	CNtlStorageGroupSystem* pGroupSystem = NTL_NEW CNtlStorageGroupSystem();
	if( !pGroupSystem->Create() )
	{
		pGroupSystem->Destroy();
		NTL_DELETE( pGroupSystem );
		return false;
	}
	m_mapStorageGroup.insert( std::make_pair( eNTL_STORAGE_GROUP_SYSTEM, pGroupSystem ) );


	// GameInfo Group
	CNtlStorageGroupGameInfo* pGroupGameInfo = NTL_NEW CNtlStorageGroupGameInfo();
	if( !pGroupGameInfo->Create() )
	{
		pGroupGameInfo->Destroy();
		NTL_DELETE( pGroupGameInfo );
		return false;
	}
	m_mapStorageGroup.insert( std::make_pair( eNTL_STORAGE_GROUP_GAMEINFO, pGroupGameInfo ) );

	// Scouter
	CNtlStorageGroupScouter* pGroupScouter = NTL_NEW CNtlStorageGroupScouter();
	if( !pGroupScouter->Create() )
	{
		pGroupScouter->Destroy();
		NTL_DELETE( pGroupScouter );
		return false;
	}
	m_mapStorageGroup.insert( std::make_pair( eNTL_STORAGE_GROUP_SCOUTER, pGroupScouter ) );

	// Quest
	CNtlStorageGroupQuest* pGroupQuest = NTL_NEW CNtlStorageGroupQuest();
	if( !pGroupQuest->Create() )
	{
		pGroupQuest->Destroy();
		NTL_DELETE( pGroupQuest );
		return false;
	}
	m_mapStorageGroup.insert( std::make_pair( eNTL_STORAGE_GROUP_QUEST,	pGroupQuest) );

	// Character
	CNtlStorageGroupCharacter* pGroupCharacter = NTL_NEW CNtlStorageGroupCharacter();
	if( !pGroupCharacter->Create() )
	{
		pGroupCharacter->Destroy();
		NTL_DELETE( pGroupCharacter );
		return false;
	}
	m_mapStorageGroup.insert( std::make_pair( eNTL_STORAGE_GROUP_CHARACTER, pGroupCharacter ) );

	return true;
}

void CNtlStorageManager::Destroy()
{
	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			pair.second->Destroy();

			NTL_DELETE( pair.second );
		}
	}
	m_mapStorageGroup.clear();
}

bool CNtlStorageManager::Load( eNTL_STORAGE_GROUP_TYPE eType, const char* filename )
{
	// 파일이 없으면 Default 값으로 로드
	CNtlStorageGroup* pGroup = GetStorageGroup( eType );
	if( pGroup )
	{
		NtlFileAttrReadOnlyRelease((RwChar*)filename);

		// Text 로 로드할 것들
		if( eType == eNTL_STORAGE_ACCOUNT ||
			eType == eNTL_STORAGE_GROUP_SYSTEM ||
			eType == eNTL_STORAGE_GROUP_GAMEINFO ||
			eType == eNTL_STORAGE_GROUP_CHARACTER )
		{
			FILE* fp = NULL;

#if defined(_MSC_VER) && (_MSC_VER >= 1400)
			if(fopen_s(&fp, filename, "rt") != 0)
				return false;
#else
			fp = fopen(g_chLogPath, "rt");
			if(fp == NULL)
				return false;
#endif

			fseek(fp, 0, SEEK_END);
			int nSize = ftell(fp);
			fseek(fp, 0, SEEK_SET);

			if( nSize == 0 )
			{
				fclose( fp );
				return false;
			}

			char* pData = NTL_NEW char[nSize];
			::ZeroMemory( pData, nSize );

			fread(pData, nSize, 1, fp );
			fclose(fp);

			// Text Serializer
			
			CNtlStorageTextSerializer s(nSize, nSize/10);
			s.In(pData, nSize);

			NTL_ARRAY_DELETE( pData );

			if( !pGroup->Load( &s ) )
				return false;
		}
		else
		{
			FILE* fp = NULL;
		
#if defined(_MSC_VER) && (_MSC_VER >= 1400)
			if(fopen_s(&fp, filename, "rb") != 0)
				return false;
#else
			fp = fopen(g_chLogPath, "rb");
			if(fp == NULL)
				return false;
#endif

			fseek(fp, 0, SEEK_END);
			int nSize = ftell(fp);
			fseek(fp, 0, SEEK_SET);

			if( nSize == 0 )
			{
				fclose( fp );
				return false;
			}

			char* pData = NTL_NEW char[nSize];
			::ZeroMemory( pData, nSize );

			fread(pData, nSize, 1, fp );
			fclose(fp);

			// Binary Serializer
			CNtlStorageBinarySerializer s(nSize, nSize/10);
			s.In(pData, nSize);

			NTL_ARRAY_DELETE( pData );

			if( !pGroup->Load( &s ) )
				return false;
		}

		return true;
	}
	else
	{
		// 그룹을 찾지 못함
		return false;
	}
}

bool CNtlStorageManager::Save( eNTL_STORAGE_GROUP_TYPE eType, const char* filename )
{
	CNtlStorageGroup* pGroup = GetStorageGroup( eType );
	if( pGroup )
	{
		NtlFileAttrReadOnlyRelease((RwChar*)filename);

		if( eType == eNTL_STORAGE_GROUP_ACCOUNT ||
			eType == eNTL_STORAGE_GROUP_SYSTEM ||
			eType == eNTL_STORAGE_GROUP_GAMEINFO ||
			eType == eNTL_STORAGE_GROUP_CHARACTER )
		{
			CNtlStorageTextSerializer s(10000, 5000);
			pGroup->Save( &s );

			FILE* fp = NULL;

#if defined(_MSC_VER) && (_MSC_VER >= 1400)
			if(fopen_s(&fp, filename, "wt") != 0)
				return false;
#else
			fp = fopen(g_chLogPath, "wt");
			if(fp == NULL)
				return false;
#endif

			fwrite(s.GetData(), s.GetDataSize(), 1, fp );
			fclose(fp);
		}
		else
		{
			CNtlStorageBinarySerializer s(10000, 5000);
			pGroup->Save( &s );

			FILE* fp = NULL;

#if defined(_MSC_VER) && (_MSC_VER >= 1400)
			if(fopen_s(&fp, filename, "wb") != 0)
				return false;
#else
			fp = fopen(g_chLogPath, "wb");
			if(fp == NULL)
				return false;
#endif

			fwrite(s.GetData(), s.GetDataSize(), 1, fp );
			fclose(fp);
		}

		return true;
	}
	else
	{
		// 그룹을 찾지 못함
		return false;
	}
}

bool CNtlStorageManager::Reset( eNTL_STORAGE_GROUP_TYPE eType )
{
	CNtlStorageGroup* pGroup = GetStorageGroup( eType );
	if( pGroup )
	{
		return pGroup->Reset();
	}
	else
	{
		return false;
	}
}

CNtlStorageGroup* CNtlStorageManager::GetStorageGroup(eNTL_STORAGE_GROUP_TYPE eType)
{
	GROUPMAP::iterator it = m_mapStorageGroup.find( eType );
	if( it == m_mapStorageGroup.end() )
	{
		// 못 찾음
		return NULL;
	}

	return (*it).second;
}

CNtlStorageUnit* CNtlStorageManager::GetStorageUnit( eNTL_STORAGE_TYPE eType )
{
	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->IsHave( eType ) )
			{
				return pair.second->GetStorageUnit( eType );
			}
		}
	}

	return NULL;

}

int CNtlStorageManager::GetIntData( unsigned int uiKey )
{
	int nData = 0;

	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->GetIntData( uiKey, nData ) )
			{
				return nData;
			}
		}
	}

	return nData;
}

std::string CNtlStorageManager::GetStringData( unsigned int uiKey )
{
	std::string strData;

	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->GetStringData( uiKey, strData ) )
			{
				return strData;
			}
		}
	}

	return strData;
}

bool CNtlStorageManager::GetBoolData( unsigned int uiKey )
{
	bool bData = false;

	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->GetBoolData( uiKey, bData ) )
			{
				return bData;
			}
		}
	}

	return bData;
}

float CNtlStorageManager::GetFloatData( unsigned int uiKey )
{
	float fData = 0.0f;

	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->GetFloatData( uiKey, fData ) )
			{
				return fData;
			}
		}
	}

	return fData;
}

bool CNtlStorageManager::SetData( unsigned int uiKey, std::string strData )
{
	// 받은 Key의 Type을 찾는다.
	eNTL_STORAGE_TYPE eType = GetNtlStorageMTContainer()->GetStorageType( uiKey );
	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->IsHave( eType ) )
			{
				if( pair.second->SetData( uiKey, strData ) )
					return true;
			}
		}
	}

	return false;
}

bool CNtlStorageManager::SetData( unsigned int uiKey, int nData )
{
	std::ostringstream outstream;
	outstream << nData;
	return SetData( uiKey, outstream.str() );
}

bool CNtlStorageManager::SetData( unsigned int uiKey, float fData )
{
	std::ostringstream outstream;
	outstream << fData;
	return SetData( uiKey, outstream.str() );
}

bool CNtlStorageManager::SetData( unsigned int uiKey, bool bData )
{
	std::string strData;
	if( bData )
		strData = dSTORAGE_TRUE;
	else
		strData = dSTORAGE_FALSE;
	return SetData( uiKey, strData );
}

bool CNtlStorageManager::SetData( unsigned int uiKey, std::wstring wstrData )
{
	char chBuffer[128];
	::WideCharToMultiByte( GetACP(), 0, wstrData.c_str(), -1, chBuffer, 128, NULL, NULL );
	std::string strData = chBuffer;
	return SetData( uiKey, strData );
}

bool CNtlStorageManager::SetData( unsigned int uiKey, const char* acData )
{
	std::string strData = acData;
	return SetData( uiKey, strData );
}

bool CNtlStorageManager::SetData( unsigned int uiKey, const wchar_t* awcData )
{
	char chBuffer[128];
	::WideCharToMultiByte( GetACP(), 0, awcData, -1, chBuffer, 128, NULL, NULL );
	std::string strData = chBuffer;
	return SetData( uiKey, strData );
}

bool CNtlStorageManager::SetCommonApplyFunc( NtlStorageUnitApplyFunc func )
{
	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
		pair.second->SetUnitApplyFunc( func );

	return true;
}

bool CNtlStorageManager::ApplyStorageType( eNTL_STORAGE_TYPE eType, unsigned int uiFlags )
{
	for each( std::pair<eNTL_STORAGE_GROUP_TYPE, CNtlStorageGroup*> pair in m_mapStorageGroup )
	{
		if( pair.second )
		{
			if( pair.second->IsHave( eType ) )
			{
				return pair.second->GetStorageUnit( eType )->Apply( uiFlags );
			}
		}
	}

	return false;
}